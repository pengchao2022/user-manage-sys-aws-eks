name: Deploy Application

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: user-registration-app
  PROJECT_NAME: user-registration

jobs:
  # Job 1: ÂàõÂª∫Âü∫Á°ÄËÆæÊñΩ
  create-infrastructure:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    outputs:
      cluster_name: ${{ steps.set-outputs.outputs.cluster_name }}
      db_endpoint: ${{ steps.set-outputs.outputs.db_endpoint }}
      db_host: ${{ steps.set-outputs.outputs.db_host }}
      db_password: ${{ steps.set-outputs.outputs.db_password }}
      ecr_repository: ${{ steps.set-outputs.outputs.ecr_repository }}
      vpc_id: ${{ steps.set-outputs.outputs.vpc_id }}
      environment: ${{ steps.env.outputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Determine environment
      id: env
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
        else
          echo "environment=dev" >> $GITHUB_OUTPUT
        fi
        echo "Selected environment: ${{ steps.env.outputs.environment }}"

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3

    - name: Terraform Init
      run: |
        cd terraform
        echo "Initializing Terraform for environment: ${{ steps.env.outputs.environment }}"
        terraform init

    - name: Terraform Format Check
      run: |
        cd terraform
        terraform fmt -check -recursive

    - name: Terraform Validate
      run: |
        cd terraform
        terraform validate

    - name: Terraform Plan
      run: |
        cd terraform
        echo "Running Terraform plan for environment: ${{ steps.env.outputs.environment }}"
        terraform plan \
          -var="environment=${{ steps.env.outputs.environment }}" \
          -var="project_name=${{ env.PROJECT_NAME }}"

    - name: Terraform Apply
      run: |
        cd terraform
        echo "Applying Terraform for environment: ${{ steps.env.outputs.environment }}"
        terraform apply \
          -var="environment=${{ steps.env.outputs.environment }}" \
          -var="project_name=${{ env.PROJECT_NAME }}" \
          -auto-approve

    - name: Get Terraform Outputs
      id: tf-outputs
      run: |
        cd terraform
        CLUSTER_NAME=$(terraform output -raw cluster_name)
        DB_ENDPOINT=$(terraform output -raw database_endpoint)
        DB_PASSWORD=$(terraform output -raw database_password)
        ECR_REPOSITORY=$(terraform output -raw ecr_repository_name 2>/dev/null || echo "${{ env.ECR_REPOSITORY }}")
        VPC_ID=$(terraform output -raw vpc_id)
        
        # ‰ªéÁ´ØÁÇπ‰∏≠ÊèêÂèñ‰∏ªÊú∫ÂêçÔºàÂéªÊéâÁ´ØÂè£Âè∑Ôºâ
        DB_HOST=$(echo "$DB_ENDPOINT" | cut -d: -f1)
        
        echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
        echo "db_endpoint=$DB_ENDPOINT" >> $GITHUB_OUTPUT
        echo "db_host=$DB_HOST" >> $GITHUB_OUTPUT
        echo "db_password=$DB_PASSWORD" >> $GITHUB_OUTPUT
        echo "ecr_repository=$ECR_REPOSITORY" >> $GITHUB_OUTPUT
        echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
        
        echo "Infrastructure outputs:"
        echo "Cluster: $CLUSTER_NAME"
        echo "DB Endpoint: $DB_ENDPOINT"
        echo "DB Host: $DB_HOST"
        echo "ECR Repository: $ECR_REPOSITORY"
        echo "VPC ID: $VPC_ID"

    - name: Set Job Outputs
      id: set-outputs
      run: |
        echo "cluster_name=${{ steps.tf-outputs.outputs.cluster_name }}" >> $GITHUB_OUTPUT
        echo "db_endpoint=${{ steps.tf-outputs.outputs.db_endpoint }}" >> $GITHUB_OUTPUT
        echo "db_host=${{ steps.tf-outputs.outputs.db_host }}" >> $GITHUB_OUTPUT
        echo "db_password=${{ steps.tf-outputs.outputs.db_password }}" >> $GITHUB_OUTPUT
        echo "ecr_repository=${{ steps.tf-outputs.outputs.ecr_repository }}" >> $GITHUB_OUTPUT
        echo "vpc_id=${{ steps.tf-outputs.outputs.vpc_id }}" >> $GITHUB_OUTPUT

    - name: Verify Infrastructure
      run: |
        echo "üîç Verifying infrastructure deployment..."
        
        # Á≠âÂæÖ EKS ÈõÜÁæ§ÂàõÂª∫ÂÆåÊàê
        echo "Waiting for EKS cluster to be active..."
        MAX_RETRIES=30
        COUNT=0
        
        while [ $COUNT -lt $MAX_RETRIES ]; do
          CLUSTER_STATUS=$(aws eks describe-cluster \
            --name ${{ steps.tf-outputs.outputs.cluster_name }} \
            --region ${{ env.AWS_REGION }} \
            --query 'cluster.status' \
            --output text 2>/dev/null || echo "NOT_FOUND")
          
          if [ "$CLUSTER_STATUS" = "ACTIVE" ]; then
            echo "‚úÖ EKS Cluster Status: $CLUSTER_STATUS"
            break
          elif [ "$CLUSTER_STATUS" = "CREATING" ]; then
            echo "‚è≥ EKS Cluster is still creating... ($((COUNT+1))/$MAX_RETRIES)"
            sleep 30
            COUNT=$((COUNT+1))
          else
            echo "‚ùå EKS Cluster Status: $CLUSTER_STATUS"
            echo "Cluster may not be ready yet, continuing with deployment..."
            break
          fi
        done
        
        if [ $COUNT -eq $MAX_RETRIES ]; then
          echo "‚ö†Ô∏è EKS cluster creation taking longer than expected, continuing deployment..."
        fi
        
        # È™åËØÅ RDS ÂÆû‰æã
        RDS_STATUS=$(aws rds describe-db-instances \
          --db-instance-identifier ${{ env.PROJECT_NAME }}-${{ steps.env.outputs.environment }}-db \
          --region ${{ env.AWS_REGION }} \
          --query 'DBInstances[0].DBInstanceStatus' \
          --output text)
        echo "RDS Instance Status: $RDS_STATUS"
        
        echo "‚úÖ Infrastructure verification completed"

  # Job 2: ÈÉ®ÁΩ≤Â∫îÁî®Âà∞ EKS
  deploy-to-eks:
    needs: create-infrastructure
    runs-on: ubuntu-latest
    environment: ${{ needs.create-infrastructure.outputs.environment }}
    
    steps:
    - name: Debug Job Outputs
      run: |
        echo "=== Debug Job Outputs ==="
        echo "Environment: ${{ needs.create-infrastructure.outputs.environment }}"
        echo "Cluster Name: ${{ needs.create-infrastructure.outputs.cluster_name }}"
        echo "DB Endpoint: ${{ needs.create-infrastructure.outputs.db_endpoint }}"
        echo "DB Host: ${{ needs.create-infrastructure.outputs.db_host }}"
        echo "ECR Repository: ${{ needs.create-infrastructure.outputs.ecr_repository }}"
        echo "VPC ID: ${{ needs.create-infrastructure.outputs.vpc_id }}"
        echo "DB Password: [hidden]"

    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Configure kubectl for EKS
      run: |
        CLUSTER_NAME="${{ needs.create-infrastructure.outputs.cluster_name }}"
        echo "Configuring kubectl for cluster: $CLUSTER_NAME"
        
        aws eks update-kubeconfig \
          --region ${{ env.AWS_REGION }} \
          --name "$CLUSTER_NAME"
        echo "‚úÖ kubectl configured for cluster: $CLUSTER_NAME"

    - name: Verify Cluster Access
      run: |
        echo "Verifying cluster access..."
        kubectl cluster-info
        kubectl get nodes
        echo "‚úÖ Successfully connected to EKS cluster"

    - name: Fix Network Issues
      run: |
        echo "üîß Fixing network issues..."
        
        # Ê£ÄÊü• CNI Áä∂ÊÄÅ
        echo "=== Checking CNI Status ==="
        kubectl get pods -n kube-system -l k8s-app=aws-node
        
        # ÈáçÂêØ CNI pods Â¶ÇÊûúÂøÖË¶Å
        echo "=== Restarting CNI Pods ==="
        kubectl delete pods -n kube-system -l k8s-app=aws-node --force --grace-period=0
        echo "Waiting for CNI pods to restart..."
        sleep 30
        
        # È™åËØÅ CNI pods ÈáçÊñ∞ÂêØÂä®
        kubectl get pods -n kube-system -l k8s-app=aws-node
        echo "‚úÖ Network fixes applied"

    - name: Deploy ALB Controller via Helm
      id: deploy-alb
      run: |
        echo "üöÄ Deploying AWS Load Balancer Controller via Helm..."
        
        CLUSTER_NAME="${{ needs.create-infrastructure.outputs.cluster_name }}"
        VPC_ID="${{ needs.create-infrastructure.outputs.vpc_id }}"
        
        echo "Cluster Name: $CLUSTER_NAME"
        echo "VPC ID: $VPC_ID"
        echo "AWS Region: ${{ env.AWS_REGION }}"
        
        # Ê∑ªÂä† EKS Helm ‰ªìÂ∫ì
        echo "=== Adding EKS Helm Repository ==="
        helm repo add eks https://aws.github.io/eks-charts
        helm repo update
        
        # Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú® ALB Controller
        EXISTING_CONTROLLER=$(helm list -n kube-system | grep aws-load-balancer-controller | wc -l)
        
        if [ "$EXISTING_CONTROLLER" -gt 0 ]; then
          echo "üîÑ ALB Controller already exists, upgrading..."
          helm upgrade aws-load-balancer-controller eks/aws-load-balancer-controller \
            -n kube-system \
            --set clusterName=$CLUSTER_NAME \
            --set serviceAccount.create=true \
            --set serviceAccount.name=aws-load-balancer-controller \
            --set region=${{ env.AWS_REGION }} \
            --set vpcId=$VPC_ID \
            --set replicaCount=2 \
            --wait
        else
          echo "üÜï Installing new ALB Controller..."
          helm install aws-load-balancer-controller eks/aws-load-balancer-controller \
            -n kube-system \
            --set clusterName=$CLUSTER_NAME \
            --set serviceAccount.create=true \
            --set serviceAccount.name=aws-load-balancer-controller \
            --set region=${{ env.AWS_REGION }} \
            --set vpcId=$VPC_ID \
            --set replicaCount=2 \
            --wait
        fi
        
        echo "‚úÖ ALB Controller Helm deployment completed"

    - name: Wait for ALB Controller to be Ready
      run: |
        echo "‚è≥ Waiting for ALB Controller pods to be ready..."
        
        # Á≠âÂæÖ ALB Controller ÂêØÂä®
        kubectl wait --for=condition=ready pod \
          -l app.kubernetes.io/name=aws-load-balancer-controller \
          -n kube-system \
          --timeout=300s
        
        # Ê£ÄÊü• ALB Controller Áä∂ÊÄÅ
        echo "=== ALB Controller Status ==="
        kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller
        
        # Ê£ÄÊü• ALB Controller Êó•Âøó
        echo "=== ALB Controller Logs (last 10 lines) ==="
        kubectl logs -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller --tail=10
        
        echo "‚úÖ ALB Controller is ready"

    - name: Verify ALB Controller Installation
      run: |
        echo "üîç Verifying ALB Controller installation..."
        
        # Ê£ÄÊü•ÈÉ®ÁΩ≤Áä∂ÊÄÅ
        echo "=== Deployment Status ==="
        kubectl get deployment -n kube-system aws-load-balancer-controller
        
        # Ê£ÄÊü•ÊúçÂä°Ë¥¶Êà∑
        echo "=== Service Account ==="
        kubectl get serviceaccount -n kube-system aws-load-balancer-controller
        
        # Ê£ÄÊü• CRDs ÊòØÂê¶ÂÆâË£ÖÔºà‰ΩøÁî®ÂÆâÂÖ®ÁöÑÊñπÂºèÔºâ
        echo "=== Custom Resource Definitions ==="
        kubectl get crd 2>/dev/null | grep -E "(alb|elb)" || echo "No ALB-related CRDs found yet (this is normal during initial deployment)"
        
        # Ê£ÄÊü• Pod Áä∂ÊÄÅ
        echo "=== Pod Status ==="
        kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller
        
        # Ê£ÄÊü• Pod Êó•ÂøóÊòØÂê¶ÊúâÈîôËØØ
        echo "=== Checking for Errors in Pod Logs ==="
        kubectl logs -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller --tail=20
        
        echo "‚úÖ ALB Controller verification completed"

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
        ECR_REPOSITORY: ${{ needs.create-infrastructure.outputs.ecr_repository }}
      run: |
        # Build the Docker image
        echo "Building Docker image for repository: $ECR_REPOSITORY"
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        
        # Push the image to ECR
        echo "Pushing Docker image to ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # Also tag as latest for the environment
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest-${{ needs.create-infrastructure.outputs.environment }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest-${{ needs.create-infrastructure.outputs.environment }}
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "‚úÖ Docker image built and pushed successfully"

    - name: Cleanup Existing Resources
      run: |
        echo "üßπ Cleaning up existing resources before deployment..."
        # Âà†Èô§ÊâÄÊúâÂ∫îÁî®Áõ∏ÂÖ≥ËµÑÊ∫êÔºàÊåáÂÆöÂëΩÂêçÁ©∫Èó¥Ôºâ
        kubectl delete deployment user-registration-app -n user-register --ignore-not-found=true --timeout=30s || true
        kubectl delete service user-registration-app-service -n user-register --ignore-not-found=true --timeout=30s || true
        kubectl delete ingress user-registration-app-ingress -n user-register --ignore-not-found=true --timeout=30s || true
        kubectl delete configmap user-registration-app-config -n user-register --ignore-not-found=true --timeout=30s || true
        kubectl delete secret database-secret -n user-register --ignore-not-found=true --timeout=30s || true
        kubectl delete secret app-secret -n user-register --ignore-not-found=true --timeout=30s || true
        
        echo "‚úÖ Cleanup completed"
        sleep 10  # Á≠âÂæÖËµÑÊ∫êÂÆåÂÖ®Ê∏ÖÁêÜ

    # ========== Êñ∞Â¢ûÔºö‰ªé namespace.yaml Êñá‰ª∂ÈÉ®ÁΩ≤ÂëΩÂêçÁ©∫Èó¥ ==========
    - name: Check and Deploy Namespace
      run: |
        echo "üìÅ Checking for namespace.yaml file..."
        
        if [ -f "k8s/namespace.yaml" ]; then
          echo "‚úÖ Found namespace.yaml file, deploying namespace..."
          kubectl apply -f k8s/namespace.yaml
          echo "‚úÖ Namespace deployed from namespace.yaml"
          
          # È™åËØÅÂëΩÂêçÁ©∫Èó¥
          echo "=== Namespace Status ==="
          kubectl get namespace user-register -o wide
        else
          echo "‚ùå ERROR: namespace.yaml file not found in k8s/ directory"
          echo "Please create a namespace.yaml file with the following content:"
          echo "---"
          echo "apiVersion: v1"
          echo "kind: Namespace"
          echo "metadata:"
          echo "  name: user-register"
          echo "  labels:"
          echo "    name: user-register"
          echo "    environment: ${{ needs.create-infrastructure.outputs.environment }}"
          echo "    project: ${{ env.PROJECT_NAME }}"
          echo "    app: user-registration"
          echo "    managed-by: github-actions"
          echo "---"
          echo ""
          echo "Create the file at k8s/namespace.yaml and commit it to your repository."
          exit 1
        fi

    - name: Create Kubernetes Secrets
      run: |
        echo "üîß Creating Kubernetes secrets in user-register namespace..."
        
        # ‰ΩøÁî®ÊòéÁ°ÆÁöÑÂèòÈáè
        DB_HOST="${{ needs.create-infrastructure.outputs.db_host }}"
        DB_PASSWORD="${{ needs.create-infrastructure.outputs.db_password }}"
        
        echo "Using values:"
        echo "DB_HOST: $DB_HOST"
        echo "DB Password: [hidden]"
        
        # ÂàõÂª∫ database-secretÔºàÊåáÂÆöÂëΩÂêçÁ©∫Èó¥Ôºâ
        echo "Creating database-secret in user-register namespace..."
        kubectl create secret generic database-secret \
          --namespace=user-register \
          --from-literal=host="$DB_HOST" \
          --from-literal=username="appuser" \
          --from-literal=password="$DB_PASSWORD"
        
        # È™åËØÅ secret ÂàõÂª∫
        echo "Verifying database-secret creation..."
        kubectl get secret database-secret --namespace=user-register
        
        # ÂàõÂª∫ app-secretÔºàÊåáÂÆöÂëΩÂêçÁ©∫Èó¥Ôºâ
        if [ -n "${{ secrets.APP_SECRET_KEY }}" ]; then
          echo "Using provided APP_SECRET_KEY"
          kubectl create secret generic app-secret \
            --namespace=user-register \
            --from-literal=secret-key="${{ secrets.APP_SECRET_KEY }}"
        else
          echo "Generating random APP_SECRET_KEY"
          kubectl create secret generic app-secret \
            --namespace=user-register \
            --from-literal=secret-key=$(openssl rand -hex 32)
        fi
        
        echo "‚úÖ Kubernetes secrets created in user-register namespace"

    - name: Verify Secrets Content
      run: |
        echo "üîç Thoroughly verifying secret content in user-register namespace..."
        
        # ËØ¶ÁªÜÊ£ÄÊü• secret ÂÜÖÂÆπ
        echo "=== Database Secret Full Details ==="
        kubectl get secret database-secret --namespace=user-register -o yaml
        
        echo "=== Database Secret Keys ==="
        kubectl get secret database-secret --namespace=user-register -o jsonpath='{.data}' | jq -r 'keys[]'
        
        echo "=== Database Secret Values (decoded) ==="
        HOST=$(kubectl get secret database-secret --namespace=user-register -o jsonpath='{.data.host}' | base64 -d)
        USERNAME=$(kubectl get secret database-secret --namespace=user-register -o jsonpath='{.data.username}' | base64 -d)
        PASSWORD=$(kubectl get secret database-secret --namespace=user-register -o jsonpath='{.data.password}' | base64 -d)
        
        echo "Host: $HOST"
        echo "Username: $USERNAME"
        echo "Password: [hidden]"
        
        # È™åËØÅÊâÄÊúâÈîÆÈÉΩÂ≠òÂú®
        if [ -n "$HOST" ] && [ -n "$USERNAME" ] && [ -n "$PASSWORD" ]; then
          echo "‚úÖ ALL SECRET KEYS ARE PRESENT AND CORRECT"
        else
          echo "‚ùå MISSING SECRET KEYS:"
          echo "Host present: $([ -n "$HOST" ] && echo "YES" || echo "NO")"
          echo "Username present: $([ -n "$USERNAME" ] && echo "YES" || echo "NO")"
          echo "Password present: $([ -n "$PASSWORD" ] && echo "YES" || echo "NO")"
          exit 1
        fi

    - name: Deploy Application Configurations
      run: |
        echo "Deploying Kubernetes configurations to user-register namespace..."
        
        # Ê£ÄÊü• YAML Êñá‰ª∂ÊòØÂê¶ÂåÖÂê´ÂëΩÂêçÁ©∫Èó¥ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÊ∑ªÂä†ÂëΩÂêçÁ©∫Èó¥ÂèÇÊï∞
        echo "=== Applying Configurations ==="
        
        # Apply ConfigMapÔºàÂ¶ÇÊûú YAML ‰∏≠Ê≤°ÊúâÊåáÂÆöÂëΩÂêçÁ©∫Èó¥ÔºåÂàôÊ∑ªÂä† -n ÂèÇÊï∞Ôºâ
        if grep -q "namespace:" k8s/configmap.yaml; then
          kubectl apply -f k8s/configmap.yaml
        else
          kubectl apply -f k8s/configmap.yaml -n user-register
        fi
        
        # Apply Deployment with the new image
        if grep -q "namespace:" k8s/deployment.yaml; then
          cat k8s/deployment.yaml | \
            sed "s|USER_REGISTRATION_APP_IMAGE|${{ steps.build-image.outputs.image }}|g" | \
            kubectl apply -f -
        else
          cat k8s/deployment.yaml | \
            sed "s|USER_REGISTRATION_APP_IMAGE|${{ steps.build-image.outputs.image }}|g" | \
            kubectl apply -f - -n user-register
        fi
        
        # Apply Service and Ingress
        if grep -q "namespace:" k8s/service.yaml; then
          kubectl apply -f k8s/service.yaml
        else
          kubectl apply -f k8s/service.yaml -n user-register
        fi
        
        if grep -q "namespace:" k8s/ingress.yaml; then
          kubectl apply -f k8s/ingress.yaml
        else
          kubectl apply -f k8s/ingress.yaml -n user-register
        fi
        
        echo "‚úÖ All Kubernetes configurations deployed to user-register namespace"

    - name: Wait for Application Deployment
      run: |
        echo "Waiting for application deployment to complete in user-register namespace..."
        # ‰ΩøÁî®Êõ¥ÈïøÁöÑË∂ÖÊó∂Êó∂Èó¥
        kubectl rollout status deployment/user-registration-app --namespace=user-register --timeout=600s
        echo "‚úÖ Application deployment completed"

    - name: Verify Application Health
      run: |
        echo "üîç Verifying application health in user-register namespace..."
        
        # Check pods
        echo "--- Running Pods ==="
        kubectl get pods --namespace=user-register -l app=user-registration-app -o wide
        
        # Check pod events and logs
        PODS=$(kubectl get pods --namespace=user-register -l app=user-registration-app -o jsonpath='{.items[*].metadata.name}')
        for POD in $PODS; do
          echo "--- Pod $POD Details ---"
          kubectl describe pod $POD --namespace=user-register
          echo "--- Pod $POD Logs ---"
          kubectl logs $POD --namespace=user-register --tail=50 || echo "No logs available"
        done
        
        # Check services
        echo "--- Services ---"
        kubectl get service user-registration-app-service --namespace=user-register
        
        # Check ingress
        echo "--- Ingress ---"
        kubectl get ingress user-registration-app-ingress --namespace=user-register
        
        echo "‚úÖ Application verification completed"

    - name: Get Application URL with ALB Wait
      id: url
      run: |
        echo "üåê Waiting for ALB provisioning in user-register namespace..."
        
        # Á≠âÂæÖ ALB ÂàõÂª∫ÔºàÊúÄÈïø 10 ÂàÜÈíüÔºâ
        echo "This may take 2-10 minutes..."
        MAX_WAIT=600
        WAITED=0
        
        while [ $WAITED -lt $MAX_WAIT ]; do
          INGRESS_HOST=$(kubectl get ingress user-registration-app-ingress --namespace=user-register -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
          
          if [ -n "$INGRESS_HOST" ]; then
            echo "üéâ ALB Successfully Provisioned!"
            echo "application_url=http://$INGRESS_HOST" >> $GITHUB_OUTPUT
            echo "üåê Application URL: http://$INGRESS_HOST"
            
            # ÊµãËØïÂ∫îÁî®ÊòØÂê¶ÂìçÂ∫î
            echo "Testing application response..."
            sleep 30  # Áªô ALB ‰∏Ä‰∫õÊó∂Èó¥ÂºÄÂßãË∑ØÁî±ÊµÅÈáè
            curl -f http://$INGRESS_HOST/health && echo "‚úÖ Application is responding!" || echo "‚ö†Ô∏è Application URL created but not responding yet"
            break
          fi
          
          # ÊØè 30 ÁßíÊòæÁ§∫ËøõÂ∫¶
          if [ $((WAITED % 60)) -eq 0 ]; then
            echo "‚è≥ Still waiting... ($((WAITED/60))m $((WAITED%60))s / $((MAX_WAIT/60))m)"
            
            # ÊòæÁ§∫ Ingress Áä∂ÊÄÅ
            echo "Current Ingress status:"
            kubectl get ingress user-registration-app-ingress --namespace=user-register -o wide
            
            # ÊòæÁ§∫ ALB Controller Êó•ÂøóÔºàÊúÄÂêéÂá†Ë°åÔºâ
            echo "ALB Controller logs:"
            kubectl logs -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller --tail=5 2>/dev/null || echo "No ALB Controller logs available"
          fi
          
          sleep 30
          WAITED=$((WAITED + 30))
        done
        
        if [ -z "$INGRESS_HOST" ]; then
          echo "‚ùå ALB not provisioned within $((MAX_WAIT/60)) minutes"
          echo "=== Debug Information ==="
          kubectl describe ingress user-registration-app-ingress --namespace=user-register
          kubectl get events --namespace=user-register --field-selector involvedObject.kind=Ingress --sort-by='.lastTimestamp'
          echo "=== ALB Controller Status ==="
          kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller
          echo "You can check later with: kubectl get ingress -n user-register"
        fi

    - name: Provide Alternative Access Methods
      if: steps.url.outputs.application_url == ''
      run: |
        echo "üîß Alternative access methods:"
        echo ""
        echo "1. Port Forwarding (immediate access):"
        echo "   kubectl port-forward svc/user-registration-app-service -n user-register 8080:80"
        echo "   Then visit: http://localhost:8080"
        echo ""
        echo "2. Check ALB status later:"
        echo "   kubectl get ingress -n user-register"
        echo ""
        echo "3. Check ALB controller logs:"
        echo "   kubectl logs -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller"

    - name: Deployment Summary
      run: |
        echo ""
        echo "üéâ DEPLOYMENT SUMMARY"
        echo "===================="
        echo "Environment: ${{ needs.create-infrastructure.outputs.environment }}"
        echo "EKS Cluster: ${{ needs.create-infrastructure.outputs.cluster_name }}"
        echo "Database Endpoint: ${{ needs.create-infrastructure.outputs.db_endpoint }}"
        echo "Database Host: ${{ needs.create-infrastructure.outputs.db_host }}"
        echo "ECR Repository: ${{ needs.create-infrastructure.outputs.ecr_repository }}"
        echo "Docker Image: ${{ steps.build-image.outputs.image }}"
        echo "Commit SHA: ${{ github.sha }}"
        echo "Deployed by: ${{ github.actor }}"
        echo "Deployment Time: $(date)"
        echo "ALB Controller: ‚úÖ Deployed via Helm"
        if [ -n "${{ steps.url.outputs.application_url }}" ]; then
          echo "üåê Application URL: ${{ steps.url.outputs.application_url }}"
        else
          echo "üåê Application URL: Not available yet (ALB still provisioning)"
          echo "   Use: kubectl port-forward svc/user-registration-app-service -n user-register 8080:80"
          echo "   Then visit: http://localhost:8080"
        fi
        echo ""