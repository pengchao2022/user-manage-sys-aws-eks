name: Deploy Application

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: user-registration-app
  PROJECT_NAME: user-registration

jobs:
  # Job 1: 创建基础设施
  create-infrastructure:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    outputs:
      cluster_name: ${{ steps.set-outputs.outputs.cluster_name }}
      db_endpoint: ${{ steps.set-outputs.outputs.db_endpoint }}
      db_host: ${{ steps.set-outputs.outputs.db_host }}
      db_password: ${{ steps.set-outputs.outputs.db_password }}
      ecr_repository: ${{ steps.set-outputs.outputs.ecr_repository }}
      environment: ${{ steps.env.outputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Determine environment
      id: env
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
        else
          echo "environment=dev" >> $GITHUB_OUTPUT
        fi
        echo "Selected environment: ${{ steps.env.outputs.environment }}"

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3

    - name: Terraform Init
      run: |
        cd terraform
        echo "Initializing Terraform for environment: ${{ steps.env.outputs.environment }}"
        terraform init

    - name: Terraform Format Check
      run: |
        cd terraform
        terraform fmt -check -recursive

    - name: Terraform Validate
      run: |
        cd terraform
        terraform validate

    - name: Terraform Plan
      run: |
        cd terraform
        echo "Running Terraform plan for environment: ${{ steps.env.outputs.environment }}"
        terraform plan \
          -var="environment=${{ steps.env.outputs.environment }}" \
          -var="project_name=${{ env.PROJECT_NAME }}"

    - name: Terraform Apply
      run: |
        cd terraform
        echo "Applying Terraform for environment: ${{ steps.env.outputs.environment }}"
        terraform apply \
          -var="environment=${{ steps.env.outputs.environment }}" \
          -var="project_name=${{ env.PROJECT_NAME }}" \
          -auto-approve

    - name: Get Terraform Outputs
      id: tf-outputs
      run: |
        cd terraform
        CLUSTER_NAME=$(terraform output -raw cluster_name)
        DB_ENDPOINT=$(terraform output -raw database_endpoint)
        DB_PASSWORD=$(terraform output -raw database_password)
        ECR_REPOSITORY=$(terraform output -raw ecr_repository_name 2>/dev/null || echo "${{ env.ECR_REPOSITORY }}")
        
        # 从端点中提取主机名（去掉端口号）
        DB_HOST=$(echo "$DB_ENDPOINT" | cut -d: -f1)
        
        echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
        echo "db_endpoint=$DB_ENDPOINT" >> $GITHUB_OUTPUT
        echo "db_host=$DB_HOST" >> $GITHUB_OUTPUT
        echo "db_password=$DB_PASSWORD" >> $GITHUB_OUTPUT
        echo "ecr_repository=$ECR_REPOSITORY" >> $GITHUB_OUTPUT
        
        echo "Infrastructure outputs:"
        echo "Cluster: $CLUSTER_NAME"
        echo "DB Endpoint: $DB_ENDPOINT"
        echo "DB Host: $DB_HOST"
        echo "ECR Repository: $ECR_REPOSITORY"

    - name: Set Job Outputs
      id: set-outputs
      run: |
        echo "cluster_name=${{ steps.tf-outputs.outputs.cluster_name }}" >> $GITHUB_OUTPUT
        echo "db_endpoint=${{ steps.tf-outputs.outputs.db_endpoint }}" >> $GITHUB_OUTPUT
        echo "db_host=${{ steps.tf-outputs.outputs.db_host }}" >> $GITHUB_OUTPUT
        echo "db_password=${{ steps.tf-outputs.outputs.db_password }}" >> $GITHUB_OUTPUT
        echo "ecr_repository=${{ steps.tf-outputs.outputs.ecr_repository }}" >> $GITHUB_OUTPUT

    - name: Verify Infrastructure
      run: |
        echo "🔍 Verifying infrastructure deployment..."
        
        # 等待 EKS 集群创建完成
        echo "Waiting for EKS cluster to be active..."
        MAX_RETRIES=30
        COUNT=0
        
        while [ $COUNT -lt $MAX_RETRIES ]; do
          CLUSTER_STATUS=$(aws eks describe-cluster \
            --name ${{ steps.tf-outputs.outputs.cluster_name }} \
            --region ${{ env.AWS_REGION }} \
            --query 'cluster.status' \
            --output text 2>/dev/null || echo "NOT_FOUND")
          
          if [ "$CLUSTER_STATUS" = "ACTIVE" ]; then
            echo "✅ EKS Cluster Status: $CLUSTER_STATUS"
            break
          elif [ "$CLUSTER_STATUS" = "CREATING" ]; then
            echo "⏳ EKS Cluster is still creating... ($((COUNT+1))/$MAX_RETRIES)"
            sleep 30
            COUNT=$((COUNT+1))
          else
            echo "❌ EKS Cluster Status: $CLUSTER_STATUS"
            echo "Cluster may not be ready yet, continuing with deployment..."
            break
          fi
        done
        
        if [ $COUNT -eq $MAX_RETRIES ]; then
          echo "⚠️ EKS cluster creation taking longer than expected, continuing deployment..."
        fi
        
        # 验证 RDS 实例
        RDS_STATUS=$(aws rds describe-db-instances \
          --db-instance-identifier ${{ env.PROJECT_NAME }}-${{ steps.env.outputs.environment }}-db \
          --region ${{ env.AWS_REGION }} \
          --query 'DBInstances[0].DBInstanceStatus' \
          --output text)
        echo "RDS Instance Status: $RDS_STATUS"
        
        echo "✅ Infrastructure verification completed"

  # Job 2: 部署应用到 EKS
  deploy-to-eks:
    needs: create-infrastructure
    runs-on: ubuntu-latest
    environment: ${{ needs.create-infrastructure.outputs.environment }}
    
    steps:
    - name: Debug Job Outputs
      run: |
        echo "=== Debug Job Outputs ==="
        echo "Environment: ${{ needs.create-infrastructure.outputs.environment }}"
        echo "Cluster Name: ${{ needs.create-infrastructure.outputs.cluster_name }}"
        echo "DB Endpoint: ${{ needs.create-infrastructure.outputs.db_endpoint }}"
        echo "DB Host: ${{ needs.create-infrastructure.outputs.db_host }}"
        echo "ECR Repository: ${{ needs.create-infrastructure.outputs.ecr_repository }}"
        echo "DB Password: [hidden]"

    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Configure kubectl for EKS
      run: |
        CLUSTER_NAME="${{ needs.create-infrastructure.outputs.cluster_name }}"
        echo "Configuring kubectl for cluster: $CLUSTER_NAME"
        
        aws eks update-kubeconfig \
          --region ${{ env.AWS_REGION }} \
          --name "$CLUSTER_NAME"
        echo "✅ kubectl configured for cluster: $CLUSTER_NAME"

    - name: Verify Cluster Access
      run: |
        echo "Verifying cluster access..."
        kubectl cluster-info
        kubectl get nodes
        echo "✅ Successfully connected to EKS cluster"

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
        ECR_REPOSITORY: ${{ needs.create-infrastructure.outputs.ecr_repository }}
      run: |
        # Build the Docker image
        echo "Building Docker image for repository: $ECR_REPOSITORY"
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        
        # Push the image to ECR
        echo "Pushing Docker image to ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # Also tag as latest for the environment
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest-${{ needs.create-infrastructure.outputs.environment }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest-${{ needs.create-infrastructure.outputs.environment }}
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "✅ Docker image built and pushed successfully"

    - name: Cleanup Existing Resources
      run: |
        echo "🧹 Cleaning up existing resources before deployment..."
        # 删除所有应用相关资源
        kubectl delete deployment user-registration-app --ignore-not-found=true --timeout=30s || true
        kubectl delete service user-registration-app-service --ignore-not-found=true --timeout=30s || true
        kubectl delete ingress user-registration-app-ingress --ignore-not-found=true --timeout=30s || true
        kubectl delete configmap user-registration-app-config --ignore-not-found=true --timeout=30s || true
        kubectl delete secret database-secret --ignore-not-found=true --timeout=30s || true
        kubectl delete secret app-secret --ignore-not-found=true --timeout=30s || true
        
        echo "✅ Cleanup completed"
        sleep 15  # 等待资源完全清理

    - name: Create Kubernetes Secrets
      run: |
        echo "Creating Kubernetes secrets..."
        
        # 首先验证数据库主机是否可用
        echo "Database host: ${{ needs.create-infrastructure.outputs.db_host }}"
        echo "Database endpoint: ${{ needs.create-infrastructure.outputs.db_endpoint }}"
        
        # 删除可能存在的旧 secret
        kubectl delete secret database-secret --ignore-not-found=true
        
        # 创建新的 database secret - 使用 db_host 而不是 db_endpoint
        kubectl create secret generic database-secret \
          --from-literal=host=${{ needs.create-infrastructure.outputs.db_host }} \
          --from-literal=username=appuser \
          --from-literal=password=${{ needs.create-infrastructure.outputs.db_password }} \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # App secret (generate if not provided)
        if [ -n "${{ secrets.APP_SECRET_KEY }}" ]; then
          echo "Using provided APP_SECRET_KEY from GitHub secrets"
          kubectl create secret generic app-secret \
            --from-literal=secret-key=${{ secrets.APP_SECRET_KEY }} \
            --dry-run=client -o yaml | kubectl apply -f -
        else
          echo "Generating random APP_SECRET_KEY"
          kubectl create secret generic app-secret \
            --from-literal=secret-key=$(openssl rand -hex 32) \
            --dry-run=client -o yaml | kubectl apply -f -
        fi
        
        echo "✅ Kubernetes secrets created"

    - name: Verify Kubernetes Secrets
      run: |
        echo "🔍 Verifying Kubernetes secrets..."
        
        # 检查 database-secret
        echo "=== Database Secret ==="
        kubectl get secret database-secret -o yaml
        
        # 验证所有必需的键都存在
        HOST_EXISTS=$(kubectl get secret database-secret -o jsonpath='{.data.host}')
        USERNAME_EXISTS=$(kubectl get secret database-secret -o jsonpath='{.data.username}') 
        PASSWORD_EXISTS=$(kubectl get secret database-secret -o jsonpath='{.data.password}')
        
        if [ -n "$HOST_EXISTS" ] && [ -n "$USERNAME_EXISTS" ] && [ -n "$PASSWORD_EXISTS" ]; then
          echo "✅ All database secret keys are present"
          echo "Host: $(echo $HOST_EXISTS | base64 -d)"
          echo "Username: $(echo $USERNAME_EXISTS | base64 -d)"
          echo "Password: [hidden]"
        else
          echo "❌ Missing keys in database secret:"
          echo "Host exists: $([ -n "$HOST_EXISTS" ] && echo "YES" || echo "NO")"
          echo "Username exists: $([ -n "$USERNAME_EXISTS" ] && echo "YES" || echo "NO")"
          echo "Password exists: $([ -n "$PASSWORD_EXISTS" ] && echo "YES" || echo "NO")"
          exit 1
        fi
        
        # 检查 app-secret
        echo "=== App Secret ==="
        SECRET_KEY_EXISTS=$(kubectl get secret app-secret -o jsonpath='{.data.secret-key}')
        if [ -n "$SECRET_KEY_EXISTS" ]; then
          echo "✅ App secret key is present"
        else
          echo "❌ App secret key is missing"
          exit 1
        fi

    - name: Deploy Application Configurations
      run: |
        echo "Deploying Kubernetes configurations..."
        
        # Apply ConfigMap
        kubectl apply -f k8s/configmap.yaml
        
        # Apply Deployment with the new image
        cat k8s/deployment.yaml | \
          sed "s|USER_REGISTRATION_APP_IMAGE|${{ steps.build-image.outputs.image }}|g" | \
          kubectl apply -f -
        
        # Apply Service and Ingress
        kubectl apply -f k8s/service.yaml
        kubectl apply -f k8s/ingress.yaml
        
        echo "✅ All Kubernetes configurations deployed"

    - name: Wait for Application Deployment
      run: |
        echo "Waiting for application deployment to complete..."
        # 使用更长的超时时间
        kubectl rollout status deployment/user-registration-app --timeout=600s
        echo "✅ Application deployment completed"

    - name: Verify Application Health
      run: |
        echo "🔍 Verifying application health..."
        
        # Check pods
        echo "--- Running Pods ---"
        kubectl get pods -l app=user-registration-app -o wide
        
        # Check services
        echo "--- Services ---"
        kubectl get service user-registration-app-service
        
        # Check ingress
        echo "--- Ingress ---"
        kubectl get ingress user-registration-app-ingress
        
        # 检查 Pod 日志
        echo "--- Pod Logs ---"
        PODS=$(kubectl get pods -l app=user-registration-app -o jsonpath='{.items[*].metadata.name}')
        for POD in $PODS; do
          echo "Logs for $POD:"
          kubectl logs $POD --tail=20 || echo "Cannot get logs for $POD"
        done
        
        echo "✅ Application verification completed"

    - name: Get Application URL
      id: url
      run: |
        # Wait for ALB to be provisioned
        echo "Waiting for ALB provisioning..."
        sleep 60
        
        INGRESS_HOST=$(kubectl get ingress user-registration-app-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
        
        if [ -n "$INGRESS_HOST" ]; then
          echo "application_url=http://$INGRESS_HOST" >> $GITHUB_OUTPUT
          echo "🎊 Application URL: http://$INGRESS_HOST"
        else
          echo "Application URL not available yet - ALB may still be provisioning"
        fi

    - name: Deployment Summary
      run: |
        echo ""
        echo "🎉 DEPLOYMENT SUMMARY"
        echo "===================="
        echo "Environment: ${{ needs.create-infrastructure.outputs.environment }}"
        echo "EKS Cluster: ${{ needs.create-infrastructure.outputs.cluster_name }}"
        echo "Database Endpoint: ${{ needs.create-infrastructure.outputs.db_endpoint }}"
        echo "Database Host: ${{ needs.create-infrastructure.outputs.db_host }}"
        echo "ECR Repository: ${{ needs.create-infrastructure.outputs.ecr_repository }}"
        echo "Docker Image: ${{ steps.build-image.outputs.image }}"
        echo "Commit SHA: ${{ github.sha }}"
        echo "Deployed by: ${{ github.actor }}"
        echo "Deployment Time: $(date)"
        if [ -n "${{ steps.url.outputs.application_url }}" ]; then
          echo "🌐 Application URL: ${{ steps.url.outputs.application_url }}"
        fi
        echo ""